
drop function if exists hashids.encode_list(bigint[], text, integer, text, boolean);
drop function if exists hashids.encode_list(integer[], text, integer, text, boolean);

CREATE OR REPLACE FUNCTION hashids.encode_list(
    in p_numbers bigint[],
    in p_salt text,
    in p_min_hash_length,
    in p_alphabet text,
    in p_zero_offset boolean DEFAULT true)
  RETURNS character varying AS
$$
-- Options Data - generated by hashids-tsql
    DECLARE
        p_numbers ALIAS for $1;
        p_zero_offset ALIAS for $2; -- adding an offset so that this can work with values from a zero based array language
        v_salt varchar(255) = N'97530E71-9E9D-4938-B41C-CBEC2EE54787'; -- have to figure how to do this dynamically
        v_alphabet varchar(255) = N'EB9VAdjYw18GDJrZ260xXgqm3kya4QNRvLoP7bM5nW'; -- have to figure how to do this dynamically
        v_seps varchar(255) = N'histuUFHCfSTcI'; -- have to figure how to do this dynamically
        v_guards varchar(255) = N'epzK'; -- have to figure how to do this dynamically
        v_minHashLength int = 8; -- have to figure how to do this dynamically
        -- Input Alphabet: N'0123456789ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

    -- Working Data
        v_numbersHashInt int = 0;
        v_lottery char(1);
        v_buffer varchar(255);
        v_last varchar(255);
        v_ret varchar(255);
        v_sepsIndex int;
        v_lastId int;
        v_count int = array_length(p_numbers, 1);
        v_i int = 0;
        v_id int = 0;
        v_number int;
        v_guardIndex int;
        v_guard char(1);
        v_halfLength int;
        v_excess int;
BEGIN

    -- Calculate numbersHashInt
    for v_lastId in 1..v_count LOOP
        v_numbersHashInt := v_numbersHashInt + (p_numbers[v_lastId] % ((v_lastId-p_zero_offset) + 100));
    END LOOP;
    
    -- Choose lottery
    v_lottery := SUBSTRING(v_alphabet, (v_numbersHashInt % length(v_alphabet)) + 1, 1); -- is this a +1 because of sql 1 based index, need to double check to see if can be replaced with param.
    v_ret := v_lottery;

    -- Encode many
    v_i := 0;
    v_id := 0;
    for v_i in 1..v_count LOOP
        v_number := p_numbers[v_i];
        raise notice '%[%]: %', p_numbers, v_i, v_number;

        v_buffer := v_lottery || v_salt || v_alphabet;
        v_alphabet := hashids.consistent_shuffle(v_alphabet, SUBSTRING(v_buffer, 1, length(v_alphabet)));
        v_last := hashids.hash(v_number, v_alphabet, p_zero_offset);
        v_ret := v_ret || v_last;

        IF (v_i + 1) < v_count THEN
            v_sepsIndex := v_number % (ascii(SUBSTRING(v_last, 1, 1)) + v_i);
            v_sepsIndex := v_sepsIndex % length(v_seps);
            v_ret := v_ret || SUBSTRING(v_seps, v_sepsIndex + 1, 1);
        END IF;

    END LOOP;
    
    ----------------------------------------------------------------------------
    -- Enforce minHashLength
    ----------------------------------------------------------------------------
    IF length(v_ret) < v_minHashLength THEN
            
        ------------------------------------------------------------------------
        -- Add first 2 guard characters
        ------------------------------------------------------------------------
        v_guardIndex := (v_numbersHashInt + ascii(SUBSTRING(v_ret, 1, 1))) % length(v_guards);
        v_guard := SUBSTRING(v_guards, v_guardIndex + 1, 1);
        v_ret := v_guard || v_ret;
        IF length(v_ret) < v_minHashLength THEN
            v_guardIndex := (v_numbersHashInt + ascii(SUBSTRING(v_ret, 3, 1))) % length(v_guards);
            v_guard := SUBSTRING(v_guards, v_guardIndex + 1, 1);
            v_ret := v_ret || v_guard;
        END IF;
        ------------------------------------------------------------------------
        -- Add the rest
        ------------------------------------------------------------------------
        WHILE length(v_ret) < v_minHashLength LOOP
            v_halfLength := COALESCE(v_halfLength, CAST((length(v_alphabet) / 2) as int));
            v_alphabet := hashids.consistent_shuffle(v_alphabet, v_alphabet);
            v_ret := SUBSTRING(v_alphabet, v_halfLength + 1, 255) || v_ret || 
                    SUBSTRING(v_alphabet, 1, v_halfLength);
            v_excess := length(v_ret) - v_minHashLength;
            IF v_excess > 0 THEN 
                v_ret := SUBSTRING(v_ret, CAST((v_excess / 2) as int) + 1, v_minHashLength);
            END IF;
        END LOOP;
    END IF;
    RETURN v_ret;
END;
$$
  LANGUAGE plpgsql IMMUTABLE
  COST 300;

CREATE OR REPLACE FUNCTION hashids.encode_list( in p_numbers bigint[] )
  RETURNS text AS
$$
-- Options Data - generated by hashids-tsql
    DECLARE
        p_numbers ALIAS for $1;
        p_salt text := ''; -- default
        p_min_hash_length integer := 0; -- default
        p_alphabet text := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'; -- default
        p_zero_offset boolean := true ; -- adding an offset so that this can work with values from a zero based array language
BEGIN
    RETURN hashids.encode_list(p_numbers, p_salt, p_min_hash_length, p_alphabet, p_zero_offset);
END;
$$
  LANGUAGE plpgsql IMMUTABLE
  COST 300;

CREATE OR REPLACE FUNCTION hashids.encode_list( 
  in p_numbers bigint[],
  in p_salt text )
  RETURNS text AS
$$
-- Options Data - generated by hashids-tsql
    DECLARE
        p_numbers ALIAS for $1;
        p_salt ALIAS for $2; -- default
        p_min_hash_length integer := 0; -- default
        p_alphabet text := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'; -- default
        p_zero_offset boolean := true ; -- adding an offset so that this can work with values from a zero based array language
BEGIN
    RETURN hashids.encode_list(p_numbers, p_salt, p_min_hash_length, p_alphabet, p_zero_offset);
END;
$$
  LANGUAGE plpgsql IMMUTABLE
  COST 300;

CREATE OR REPLACE FUNCTION hashids.encode_list( 
  in p_numbers bigint[],
  in p_salt text,
  in p_min_hash_length integer )
  RETURNS text AS
$$
-- Options Data - generated by hashids-tsql
    DECLARE
        p_numbers ALIAS for $1;
        p_salt ALIAS for $2; -- default
        p_min_hash_length ALIAS for $3; -- default
        p_alphabet text := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'; -- default
        p_zero_offset boolean := true ; -- adding an offset so that this can work with values from a zero based array language
BEGIN
    RETURN hashids.encode_list(p_numbers, p_salt, p_min_hash_length, p_alphabet, p_zero_offset);
END;
$$
  LANGUAGE plpgsql IMMUTABLE
  COST 300;


